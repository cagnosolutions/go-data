package dopedb

import (
	"bytes"
	"encoding/json"
	"fmt"
	"testing"
)

var jsonData = []byte(`[
  {
    "name": "Robin Hood",
    "department": "",
    "manager": "",
    "salary": 200
  },
  {
    "name": "Arsene Wenger",
    "department": "Bar",
    "manager": "Friar Tuck",
    "salary": 50
  },
  {
    "name": "Friar Tuck",
    "department": "Foo",
    "manager": "Robin Hood",
    "salary": 100
  },
  {
    "name": "Little John",
    "department": "Foo",
    "manager": "Robin Hood",
    "salary": 100
  },
  {
    "name": "Sam Allardyce",
    "department": "",
    "manager": "",
    "salary": 250
  },
  {
    "name": "Dimi Berbatov",
    "department": "Foo",
    "manager": "Little John",
    "salary": 50
  }
]`)

var msgPackData = []byte{
	221, 0, 0, 0, 1, 223, 0, 0, 0, 4, 164, 110, 97, 109, 101, 170, 82, 111, 98, 105,
	110, 32, 72, 111, 111, 100, 170, 100, 101, 112, 97, 114, 116, 109, 101, 110, 116, 160, 167, 109,
	97, 110, 97, 103, 101, 114, 160, 166, 115, 97, 108, 97, 114, 121, 204, 200,
}

type Items struct {
	Name       string `json:"name"`
	Department string `json:"department"`
	Manager    string `json:"manager"`
	Salary     int    `json:"salary"`
}

func TestEncoder1(t *testing.T) {

	out := []byte{
		0x96, 0x84, 0xA4, 0x6E, 0x61, 0x6D, 0x65, 0xAA, 0x52, 0x6F, 0x62, 0x69, 0x6E, 0x20,
		0x48, 0x6F, 0x6F, 0x64, 0xAA, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6D, 0x65, 0x6E,
		0x74, 0xA0, 0xA7, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72, 0xA0, 0xA6, 0x73, 0x61,
		0x6C, 0x61, 0x72, 0x79, 0xCC, 0xC8, 0x84, 0xA4, 0x6E, 0x61, 0x6D, 0x65, 0xAD, 0x41,
		0x72, 0x73, 0x65, 0x6E, 0x65, 0x20, 0x57, 0x65, 0x6E, 0x67, 0x65, 0x72, 0xAA, 0x64,
		0x65, 0x70, 0x61, 0x72, 0x74, 0x6D, 0x65, 0x6E, 0x74, 0xA3, 0x42, 0x61, 0x72, 0xA7,
		0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72, 0xAA, 0x46, 0x72, 0x69, 0x61, 0x72, 0x20,
		0x54, 0x75, 0x63, 0x6B, 0xA6, 0x73, 0x61, 0x6C, 0x61, 0x72, 0x79, 0x32, 0x84, 0xA4,
		0x6E, 0x61, 0x6D, 0x65, 0xAA, 0x46, 0x72, 0x69, 0x61, 0x72, 0x20, 0x54, 0x75, 0x63,
		0x6B, 0xAA, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6D, 0x65, 0x6E, 0x74, 0xA3, 0x46,
		0x6F, 0x6F, 0xA7, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72, 0xAA, 0x52, 0x6F, 0x62,
		0x69, 0x6E, 0x20, 0x48, 0x6F, 0x6F, 0x64, 0xA6, 0x73, 0x61, 0x6C, 0x61, 0x72, 0x79,
		0x64, 0x84, 0xA4, 0x6E, 0x61, 0x6D, 0x65, 0xAB, 0x4C, 0x69, 0x74, 0x74, 0x6C, 0x65,
		0x20, 0x4A, 0x6F, 0x68, 0x6E, 0xAA, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6D, 0x65,
		0x6E, 0x74, 0xA3, 0x46, 0x6F, 0x6F, 0xA7, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72,
		0xAA, 0x52, 0x6F, 0x62, 0x69, 0x6E, 0x20, 0x48, 0x6F, 0x6F, 0x64, 0xA6, 0x73, 0x61,
		0x6C, 0x61, 0x72, 0x79, 0x64, 0x84, 0xA4, 0x6E, 0x61, 0x6D, 0x65, 0xAD, 0x53, 0x61,
		0x6D, 0x20, 0x41, 0x6C, 0x6C, 0x61, 0x72, 0x64, 0x79, 0x63, 0x65, 0xAA, 0x64, 0x65,
		0x70, 0x61, 0x72, 0x74, 0x6D, 0x65, 0x6E, 0x74, 0xA0, 0xA7, 0x6D, 0x61, 0x6E, 0x61,
		0x67, 0x65, 0x72, 0xA0, 0xA6, 0x73, 0x61, 0x6C, 0x61, 0x72, 0x79, 0xCC, 0xFA, 0x84,
		0xA4, 0x6E, 0x61, 0x6D, 0x65, 0xAD, 0x44, 0x69, 0x6D, 0x69, 0x20, 0x42, 0x65, 0x72,
		0x62, 0x61, 0x74, 0x6F, 0x76, 0xAA, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6D, 0x65,
		0x6E, 0x74, 0xA3, 0x46, 0x6F, 0x6F, 0xA7, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72,
		0xAB, 0x4C, 0x69, 0x74, 0x74, 0x6C, 0x65, 0x20, 0x4A, 0x6F, 0x68, 0x6E, 0xA6, 0x73,
		0x61, 0x6C, 0x61, 0x72, 0x79, 0x32,
	}

	var items []any
	err := json.Unmarshal(jsonData, &items)
	if err != nil {
		t.Errorf("error unmarshaling json data: %s", err)
	}
	for i, it := range items {
		v := it.(map[string]any)["salary"]
		if v.(float64) < 256 {
			items[i].(map[string]any)["salary"] = uint8(v.(float64))
		}
		fmt.Printf("%#v\n", it)
	}

	buf := new(bytes.Buffer)
	enc := NewEncoder(buf)
	err = enc.Encode(items)
	if err != nil {
		t.Errorf("error encoding: %s", err)
	}

	fmt.Printf("encoded data: %#v\n", buf.Bytes())

	if !bytes.Equal(buf.Bytes(), out) {
		t.Errorf("did not encode correctly\n got=%#v\nwant=%#v\n", buf.Bytes(), out)
	}
}

func TestEncoder2(t *testing.T) {

	in := map[string]any{
		"compact": true,
		"schema":  0,
	}
	out := []byte{
		0x82, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0xc3, 0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x0,
	}

	buf := new(bytes.Buffer)
	enc := NewEncoder(buf)

	err := enc.Encode(in)
	if err != nil {
		t.Errorf("error encoding: %s", err)
	}
	fmt.Printf("encoded data: %#v\n", buf.Bytes())

	if !bytes.Equal(buf.Bytes(), out) {
		t.Errorf("did not encod correctly\n got=%#v\nwant=%#v\n", buf.Bytes(), out)
	}

}

func TestDecoder(t *testing.T) {

	buf := new(bytes.Buffer)
	enc := NewEncoder(buf)
	dat := []any{float32(3.14159), "this is a test"}
	enc.Encode(dat)
	fmt.Printf("encoded data: %#v\n", buf.Bytes())

	dec := NewDecoder(buf)
	var out any
	dec.Decode(&out)

	fmt.Printf("decoded data: (%T) %#v\n", out, out)
}
